<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Auto-Scaled Lasso Select with Localmap</title>
    <style>
        body {
            margin: 0;
        }

        svg {
            width: 100vw;
            height: 100vh;
            display: block;
            background-color: #f0f0f0;
            touch-action: none;
        }

        circle {
            fill: steelblue;
            opacity: 0.7;
        }

        circle.selected {
            fill: orange;
            stroke: black;
            stroke-width: 1;
        }

        path.lasso {
            fill: rgba(0, 0, 0, 0.1);
            stroke: #666;
            stroke-width: 1.5;
            stroke-dasharray: 4 2;
            stroke-dashoffset: 0;
            animation: march 1s linear infinite;
            pointer-events: none;
        }

        @keyframes march {
            to {
                stroke-dashoffset: -6;
            }
        }
    </style>
</head>

<body>
    <svg></svg>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const slug = "nl-nudes-sexting"; // <-- Replace with your dataset slug
        const path = `data/datasets/${slug}/localmap.json`;

        const width = window.innerWidth;
        const height = window.innerHeight;
        const margin = 20;
        const BASE_RADIUS = 5 * (window.devicePixelRatio || 1);

        const svg = d3.select("svg")
            .attr("width", width)
            .attr("height", height);

        const container = svg.append("g");

        let xScale, yScale;
        let lassoPath = null;
        let coords = [];

        // Prevent native scroll from interrupting lasso on mobile
        svg.node().addEventListener("touchstart", function (e) {
            if (e.touches.length === 1) e.preventDefault();
        }, { passive: false });

        d3.json(path).then(raw => {
            const data = raw.map(([i, [x, y]]) => ({ i, x, y }));

            const xExtent = d3.extent(data, d => d.x);
            const yExtent = d3.extent(data, d => d.y);

            const dataWidth = xExtent[1] - xExtent[0];
            const dataHeight = yExtent[1] - yExtent[0];
            const dataAspect = dataWidth / dataHeight;

            const screenWidth = width - 2 * margin;
            const screenHeight = height - 2 * margin;
            const screenAspect = screenWidth / screenHeight;

            // Determine fit mode and adjust range
            let xRange, yRange;

            if (dataAspect > screenAspect) {
                // Fit width, center vertically
                const scaledHeight = screenWidth / dataAspect;
                const yOffset = (screenHeight - scaledHeight) / 2;
                xRange = [margin, width - margin];
                yRange = [height - margin - yOffset, margin + yOffset];
            } else {
                // Fit height, center horizontally
                const scaledWidth = screenHeight * dataAspect;
                const xOffset = (screenWidth - scaledWidth) / 2;
                xRange = [margin + xOffset, width - margin - xOffset];
                yRange = [height - margin, margin];
            }

            // Now define the scales
            xScale = d3.scaleLinear().domain(xExtent).range(xRange);
            yScale = d3.scaleLinear().domain(yExtent).range(yRange);

            const circles = container.selectAll("circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.y))
                .attr("r", BASE_RADIUS);

            const zoom = d3.zoom()
                .scaleExtent([0.5, 10])
                .filter((event) => {
                    // Allow wheel zoom (trackpad or mouse wheel)
                    if (event.type === "wheel") return true;

                    // Allow 2-finger touch zoom
                    if (event.type === "touchstart") {
                        return event.touches && event.touches.length >= 2;
                    }

                    // Disallow drag-to-zoom on single-touch or mouse
                    return false;
                })
                .on("zoom", (event) => {
                    const { k } = event.transform;
                    container.attr("transform", event.transform);
                    container.selectAll("circle").attr("r", BASE_RADIUS / k);
                });

            svg.call(zoom);

            svg.call(d3.drag()
                .on("start", (event) => {
                    const isMultiTouch =
                        event.sourceEvent.type.startsWith("touch") &&
                        event.sourceEvent.touches &&
                        event.sourceEvent.touches.length > 1;

                    if (isMultiTouch) return;
                    coords = [];
                    if (lassoPath) lassoPath.remove();
                    lassoPath = svg.append("path").attr("class", "lasso");
                })
                .on("drag", (event) => {
                    coords.push([event.x, event.y]);
                    if (lassoPath) lassoPath.attr("d", d3.line()(coords));
                })
                .on("end", () => {
                    if (!coords.length) return;

                    const transform = d3.zoomTransform(container.node());

                    circles.classed("selected", d => {
                        const sx = transform.applyX(xScale(d.x));
                        const sy = transform.applyY(yScale(d.y));
                        return pointInPolygon([sx, sy], coords);
                    });

                    if (lassoPath) {
                        lassoPath.remove();
                        lassoPath = null;
                    }
                    coords = [];
                }));
        });

        function pointInPolygon([x, y], vs) {
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const [xi, yi] = vs[i], [xj, yj] = vs[j];
                const intersect =
                    yi > y !== yj > y &&
                    x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
                if (intersect) inside = !inside;
            }
            return inside;
        }
    </script>
</body>

</html>