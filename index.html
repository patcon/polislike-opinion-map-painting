<!DOCTYPE html>
<html>
  <head>
    <style>
      #plot-wrapper {
        display: flex;
        width: 100%;
        gap: 20px;
      }
      svg {
        border: 1px solid #ccc;
        flex: 1;
        height: 450px;
        width: 100%;
      }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-lasso@1.0.0/build/d3-lasso.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />
  </head>
  <body>
    <a
      class="github-fork-ribbon"
      href="https://github.com/patcon/polislike-opinion-map-painting"
      data-ribbon="Fork me on GitHub"
      title="Fork me on GitHub"
      >Fork me on GitHub</a
    >
    <label for="color">Choose color: </label>
    <input type="color" id="color" value="#ff0000" />
    <span>(Cmd-click for additive)</span>

    <div id="color-palette" style="margin-top: 8px">
      <!-- swatches inserted below -->
    </div>

    <!-- <label for="selection-mode">Selection mode:</label>
    <select id="selection-mode">
      <option value="brush">Rectangle (Brush)</option>
      <option value="lasso">Freeform (Lasso)</option>
    </select> -->

    <div id="plot-wrapper">
      <svg id="plot1"></svg>
      <svg id="plot2"></svg>
      <svg id="plot3"></svg>
    </div>

    <div
      id="label-counts"
      style="margin-top: 12px; font-family: sans-serif"
    ></div>

    <script>
      let X1, X2, X3;

      // let selectionMode = "brush";
      // document
      //   .getElementById("selection-mode")
      //   .addEventListener("change", (e) => {
      //     selectionMode = e.target.value;
      //     // Re-render to install the new interaction mode
      //     renderAllPlots();
      //   });

      let convo_slug = "bg2050";
      Promise.all([
        d3.json(`data/${convo_slug}/pca.json`),
        d3.json(`data/${convo_slug}/pacmap.json`),
        d3.json(`data/${convo_slug}/localmap.json`),
      ]).then(([_X1, _X2, _X3]) => {
        X1 = _X1;
        X2 = _X2;
        X3 = _X3;

        const N = X1.length;

        const colorByIndex = Array(N).fill(null);
        let selectedIndicesGlobal = new Set();

        const width = 450,
          height = 450;
        let isShiftPressed = false;

        function getScales(X, width, height, padding = 40) {
          const xExtent = d3.extent(X, (d) => d[0]);
          const yExtent = d3.extent(X, (d) => d[1]);

          return {
            x: d3
              .scaleLinear()
              .domain(xExtent)
              .range([padding, width - padding]),
            y: d3
              .scaleLinear()
              .domain(yExtent)
              .range([height - padding, padding]), // flip Y for SVG coords
          };
        }

        const presetColors = [
          "#ff0000",
          "#00cc00",
          "#0066ff",
          "#ff9900",
          "#cc00cc",
        ];

        function renderColorPalette() {
          const container = document.getElementById("color-palette");
          container.innerHTML = presetColors
            .map(
              (color) => `
        <span 
          style="
            display:inline-block;
            width:20px; height:20px;
            background:${color};
            border:1px solid #888;
            margin-right:5px;
            cursor:pointer;
          "
          title="${color}"
          onclick="document.getElementById('color').value = '${color}'"
        ></span>`
            )
            .join("");
        }

        function updateLabelCounts() {
          const counts = {};
          for (const color of colorByIndex) {
            if (color) {
              counts[color] = (counts[color] || 0) + 1;
            }
          }

          const container = document.getElementById("label-counts");
          const entries = Object.entries(counts)
            .map(
              ([color, count]) =>
                `<span style="margin-right: 12px;">
          <span style="display:inline-block; width:14px; height:14px; background:${color}; border:1px solid #aaa; margin-right:5px; vertical-align:middle;"></span>
          ${count}
        </span>`
            )
            .join("");

          container.innerHTML = entries || "(No selections yet)";
        }

        const lineGenerator = d3.line();

        function pointInPolygon(point, vs) {
          let x = point[0],
            y = point[1];
          let inside = false;
          for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
            let xi = vs[i][0],
              yi = vs[i][1];
            let xj = vs[j][0],
              yj = vs[j][1];
            let intersect =
              yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
            if (intersect) inside = !inside;
          }
          return inside;
        }

        function renderPlot(svgId, data, title) {
          const svg = d3.select(svgId);
          const scales = getScales(data, width, height);

          svg.selectAll("*").remove(); // Clear

          // ðŸ‘‰ Add title at the top center
          svg
            .append("text")
            .attr("x", width / 2)
            .attr("y", 25)
            .attr("text-anchor", "middle")
            .attr("font-size", "16px")
            .attr("font-weight", "bold")
            .text(title);

          // Draw points
          svg
            .selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
            .attr("cx", (d) => scales.x(d[0]))
            .attr("cy", (d) => scales.y(d[1]))
            .attr("r", 5)
            .attr("fill-opacity", 0.3)
            .attr("fill", (_, i) => colorByIndex[i] || "rgba(0,0,0,0.5)");

          let coords = [];

          function drawPath() {
            svg.select("#lasso").remove();
            svg
              .append("path")
              .attr("id", "lasso")
              .style("stroke", "black")
              .style("stroke-width", 2)
              .style("fill", "#00000054")
              .attr("d", lineGenerator(coords));
          }

          function dragStart() {
            coords = [];
            svg.select("#lasso").remove();
            svg.append("path").attr("id", "lasso");
          }

          function dragMove(event) {
            coords.push([event.x, event.y]);
            drawPath();
          }

          function dragEnd(event) {
            const selectedColor = document.getElementById("color").value;
            const additive = isShiftPressed || event.sourceEvent?.metaKey;

            if (!additive) {
              colorByIndex.fill(null);
              selectedIndicesGlobal.clear();
            }

            svg.selectAll("circle").each(function (d, i) {
              const cx = scales.x(d[0]);
              const cy = scales.y(d[1]);
              if (pointInPolygon([cx, cy], coords)) {
                colorByIndex[i] = selectedColor;
                selectedIndicesGlobal.add(i);
              }
            });

            renderAllPlots();

            updateLabelCounts();
          }

          const drag = d3
            .drag()
            .on("start", dragStart)
            .on("drag", dragMove)
            .on("end", dragEnd);

          svg.call(drag);
        }

        function renderAllPlots() {
          renderPlot("#plot1", X1, "PCA projection");
          renderPlot("#plot2", X2, "PaCMAP projection");
          renderPlot("#plot3", X3, "LocalMAP projection");
        }

        renderAllPlots();

        updateLabelCounts();
        renderColorPalette();

        window.addEventListener("keydown", (e) => {
          if (e.key === "Shift") isShiftPressed = true;
        });

        window.addEventListener("keyup", (e) => {
          if (e.key === "Shift") isShiftPressed = false;
        });
      });
    </script>
  </body>
</html>
